# 二分查找

## 简介

二分查找是对有序数组进行快速查找的算法

## 原理

举例说明：假设一个长度为15的有序数组 `[1,3,6,7,9,11,12,13,15,17,23,24,25,28,30]`,想要查找变量`var`是否在数组中，可以采用以下方式：

- 遍历查找：从头遍历数组，挨个匹配指定位置的值是否与变量`var`相等，如果`var`的值是28，那么需要比较14次

- 二分查找：因为数组是有序的，可以先从中间进行比较，如果`mid == var` ,则直接返回；如果`mid > var`,则取`1/4`处进行判断；如果`mid < var`,则取`3/4`处进行判断；
如此进行下去，如果`var`的值是28，那么需要比较`3~4`次

这只是长度为15的有序数组，如果数组的长度为100、1000、10000、100万甚至更大，那么更能体现出二分查找的优势来。

二分查找需要的步数`m`与有序数组的长度`n`之间的关系为：

    m = logn

举例展示二分查找性能对比

|  m   | n  |
|  :----:  | :----: |
| 10  | 1000 |
| 20  | 100w |
| 32  | 4bn |

由此可见，基数`n`越大，二分查找的性能越明显

应用条件：

- 元素存储在数组中
- 数组中的元素必须是有序的

# 时间复杂度

    m = O(logn)

## 代码实现

```golang
// 二分查找
// n：有序数组
// v：要查找的值
// return：-1 查不到结果，>=0 v值对应的下标
func binarySearch(n []int, v int) int {
	min, max := 0, len(n)-1
	for min <= max {
		mid := (min + max) / 2
		if n[mid] == v {
			return mid
		} else if n[mid] > v {
			max = mid - 1
		} else {
			min = mid + 1
		}
	}
	return -1
}
```

